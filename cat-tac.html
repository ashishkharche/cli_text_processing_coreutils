<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>cat and tac - Command line text processing with GNU Coreutils</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Command line text processing with GNU Coreutils"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=cat-tac.html class=active><strong aria-hidden=true>1.</strong> cat and tac</a><li class="chapter-item expanded"><a href=head-tail.html><strong aria-hidden=true>2.</strong> head and tail</a><li class="chapter-item expanded"><a href=paste.html><strong aria-hidden=true>3.</strong> paste</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli_text_processing_coreutils>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Command line text processing with GNU Coreutils</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/cli_text_processing_coreutils title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=cat-and-tac><a class=header href=#cat-and-tac>cat and tac</a></h1><p><code>cat</code> derives its name from con<strong>cat</strong>enation, but it provides other nifty options too.<p><code>tac</code> is used to reverse the input line wise for further text processing.<h2 id=creating-text-files><a class=header href=#creating-text-files>Creating text files</a></h2><p>Yeah, <code>cat</code> can be used to write contents to a file by typing them from the terminal itself. If you invoke <code>cat</code> without providing file arguments or <code>stdin</code> from a pipe, it will wait for you to type the content. After you are done typing all the text you want to save, press Enter key and then <code>Ctrl+d</code> key combination. If you don't want the last line to have a newline character, press <code>Ctrl+d</code> twice instead of Enter and <code>Ctrl+d</code>. See also <a href=https://unix.stackexchange.com/q/16333/109046>unix.stackexchange: difference between Ctrl+c and Ctrl+d</a>.<pre><code class=language-bash># press Enter key and Ctrl+d after typing all the required characters
$ cat > greeting.txt
Hi there
Have a nice day
</code></pre><p>In the above example, the output of <code>cat</code> is redirected to a file named <code>greeting.txt</code>. If you don't redirect the <code>stdout</code>, each line will be echoed as you type. You can check the contents of the file you just created by using <code>cat</code> again.<pre><code class=language-bash>$ cat greeting.txt
Hi there
Have a nice day
</code></pre><p><strong>Here Documents</strong> is another popular way to create such files. Especially inside shell scripts, since pressing <code>Ctrl+d</code> interactively won't be possible. Here's an example:<pre><code class=language-bash># > and a space at the start of lines are only present in interactive mode
# won't be needed in a shell script
# EOF is typically used as the identifier
$ cat << 'EOF' > fruits.txt
> banana
> papaya
> mango
> EOF

$ cat fruits.txt
banana
papaya
mango
</code></pre><p>The termination string is enclosed in single quotes to prevent parameter expansion, command substitution, etc. You can also use <code>\string</code> for this purpose. If you use <code><&LT-</code> instead of <code><<</code>, you can use leading tab characters for indentation purposes. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Here-Documents>bash manual: Here Documents</a> and <a href=https://stackoverflow.com/q/2953081/4082052>stackoverflow: here-documents</a> for more details.<blockquote><p><img src=./images/info.svg alt=info> Note that creating files as shown above isn't restricted to <code>cat</code>, it can be applied to any command waiting for <code>stdin</code>.</blockquote><pre><code class=language-bash>$ tr 'a-z' 'A-Z' << 'end' > op.txt
> hi there
> have a nice day
> end
$ cat op.txt
HI THERE
HAVE A NICE DAY
</code></pre><h2 id=concatenate-files><a class=header href=#concatenate-files>Concatenate files</a></h2><p>Here's some examples to showcase <code>cat</code>'s main utility. One or more files can be given as arguments.<pre><code class=language-bash>$ cat greeting.txt fruits.txt nums.txt
Hi there
Have a nice day
banana
papaya
mango
3.14
42
1000
</code></pre><p>To save the output of concatenation, use your shell's redirection features.<pre><code class=language-bash>$ cat greeting.txt fruits.txt nums.txt > op.txt

$ cat op.txt
Hi there
Have a nice day
banana
papaya
mango
3.14
42
1000
</code></pre><h2 id=accepting-stdin-data><a class=header href=#accepting-stdin-data>Accepting stdin data</a></h2><p>You can represent <code>stdin</code> data using <code>-</code> as a file argument. If file arguments are not present, <code>cat</code> will read from <code>stdin</code> data if present or wait for interactive input as seen earlier.<pre><code class=language-bash># only stdin
$ echo 'apple banana cherry' | cat
apple banana cherry

$ echo 'apple banana cherry' | cat greeting.txt -
Hi there
Have a nice day
apple banana cherry

$ echo 'apple banana cherry' | cat - greeting.txt
apple banana cherry
Hi there
Have a nice day

$ printf 'Numbers' | cat - nums.txt
Numbers3.14
42
1000
</code></pre><h2 id=squeeze-consecutive-empty-lines><a class=header href=#squeeze-consecutive-empty-lines>Squeeze consecutive empty lines</a></h2><p>As mentioned before, <code>cat</code> provides many features beyond concatenation. Consider this sample <code>stdin</code> data:<pre><code class=language-bash>$ printf 'hello\n\n\nworld\n\nhave a nice day\n'
hello


world

have a nice day
</code></pre><p>You can use the <code>-s</code> option to squeeze consecutive empty lines to a single empty line. If present, leading and trailing empty lines will also be squeezed, won't be completely removed. You can modify the below example to test it out.<pre><code class=language-bash>$ printf 'hello\n\n\nworld\n\nhave a nice day\n' | cat -s
hello

world

have a nice day
</code></pre><h2 id=prefix-line-numbers><a class=header href=#prefix-line-numbers>Prefix line numbers</a></h2><p>The <code>-n</code> option will prefix line number and a tab character to each input line. You can use <code>-b</code> option instead if you don't want empty lines to be numbered.<pre><code class=language-bash>$ cat -n greeting.txt fruits.txt nums.txt
     1  Hi there
     2  Have a nice day
     3  banana
     4  papaya
     5  mango
     6  3.14
     7  42
     8  1000

# number only non-empty lines
$ printf 'apple\n\nbanana\n\ncherry\n' | cat -b
     1  apple

     2  banana

     3  cherry
</code></pre><blockquote><p><img src=./images/info.svg alt=info> Use <code>nl</code> command if you want more customization options for numbering.</blockquote><h2 id=viewing-special-characters><a class=header href=#viewing-special-characters>Viewing special characters</a></h2><p>Characters like backspace and carriage return will mangle the contents if viewed naively on the terminal. Characters like NUL won't even be visible. You can use the <code>-v</code> option to show such characters using the caret notation (see <a href=https://en.wikipedia.org/wiki/ASCII_control_characters#Control_code_chart>wikipedia: Control code chart</a> for details). See <a href=https://unix.stackexchange.com/q/522297/109046>this unix.stackexchange thread</a> for non-ASCII character examples.<pre><code class=language-bash>$ printf 'car\bt\nbike\rp\n'
cat
pike
$ printf 'car\bt\nbike\rp\n' | cat -v
car^Ht
bike^Mp

# NUL character
$ printf 'car\0jeep\0bus\0' | cat -v
car^@jeep^@bus^@

# form-feed and vertical-tab
$ printf '1 2\t3\f4\v5\n' | cat -v
1 2     3^L4^K5
</code></pre><p>The <code>-v</code> option doesn't cover the newline and tab characters. You can use the <code>-T</code> option to spot tab characters.<pre><code class=language-bash>$ printf 'good food\tnice dice\n' | cat -T
good food^Inice dice
</code></pre><p>The <code>-E</code> option adds a <code>$</code> marker at the end of input lines. This is useful to spot invisible trailing characters.<pre><code class=language-bash>$ printf 'ice   \nwater\n cool  \n' | cat -E
ice   $
water$
 cool  $
</code></pre><p>The following options combine two or more of the above options:<ul><li><code>-e</code> option is equivalent to <code>-vE</code><li><code>-t</code> option is equivalent to <code>-vT</code><li><code>-A</code> option is equivalent to <code>-vET</code></ul><pre><code class=language-bash>$ printf 'car\bt\nbike\rp\n' | cat -e
car^Ht$
bike^Mp$

$ printf '1 2\t3\f4\v5\n' | cat -t
1 2^I3^L4^K5

$ printf '1 2\t3\f4\v5\n' | cat -A
1 2^I3^L4^K5$
</code></pre><h2 id=useless-use-of-cat><a class=header href=#useless-use-of-cat>Useless use of cat</a></h2><p>Using <code>cat</code> to view the contents of a file, to concatenate them, etc is well and good. But, using <code>cat</code> when it is not needed is a bad habit that you should avoid. See <a href=https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat>wikipedia: UUOC</a> and <a href=http://porkmail.org/era/unix/award.html>Useless Use of Cat Award</a> for more details.<p>Most commands that you'll see in this book can directly work with file arguments, so you shouldn't use <code>cat</code> and pipe the contents for such cases. Here's a single file example:<pre><code class=language-bash># useless use of cat
$ cat greeting.txt | sed -E 's/\w+/\L\u&/g'
Hi There
Have A Nice Day

# sed can handle file arguments
$ sed -E 's/\w+/\L\u&/g' greeting.txt
Hi There
Have A Nice Day
</code></pre><p>If you prefer having the file argument before the command, you can still use your shell's redirection feature to supply input data instead of <code>cat</code>. This also applies to commands like <code>tr</code> that do not accept file arguments.<pre><code class=language-bash># useless use of cat
$ cat greeting.txt | tr 'a-z' 'A-Z'
HI THERE
HAVE A NICE DAY

# use shell redirection instead
$ &LTgreeting.txt tr 'a-z' 'A-Z'
HI THERE
HAVE A NICE DAY
</code></pre><p>Such useless use of <code>cat</code> isn't noticeable unless you are dealing with large input files. Especially for commands like <code>tac</code> and <code>tail</code> which will have to wait for all the data to be read instead of directly processing from the end of the file if they had been passed as arguments (or using shell redirection).<p>If you are dealing with multiple files, then the use of <code>cat</code> will depend upon the results desired. Here's some examples:<pre><code class=language-bash># match lines containing 'o' or '0'
# -n option adds line number prefix
$ cat greeting.txt fruits.txt nums.txt | grep -n '[o0]'
5:mango
8:1000
$ grep -n '[o0]' greeting.txt fruits.txt nums.txt
fruits.txt:3:mango
nums.txt:3:1000

# count the number of lines containing 'o' or '0'
$ grep -c '[o0]' greeting.txt fruits.txt nums.txt
greeting.txt:0
fruits.txt:1
nums.txt:1
$ cat greeting.txt fruits.txt nums.txt | grep -c '[o0]'
2
</code></pre><p>For some use cases like in-place editing with <code>sed</code>, you can't use <code>cat</code> or shell redirection at all. The files have to be passed as arguments only. To conclude, don't use <code>cat</code> just to pass the input as <code>stdin</code> for another command unless you really need to.<h2 id=tac><a class=header href=#tac>tac</a></h2><p><code>tac</code> will also concatenate file contents, but it will display the input lines in reversed order. Here's some examples:<pre><code class=language-bash>$ tac greeting.txt
Have a nice day
Hi there

# stdin example
$ seq 3 | tac
3
2
1
</code></pre><p>Reversing input lines makes some of the text processing tasks easier. For example, if there multiple matches but you want only the last such match. See my ebooks on <a href=https://github.com/learnbyexample/learn_gnused>GNU sed</a> and <a href=https://github.com/learnbyexample/learn_gnuawk>GNU awk</a> for more examples.<pre><code class=language-bash>$ cat log.txt
--> warning 1
a,b,c,d
42
--> warning 2
x,y,z
--> warning 3
4,3,1

$ tac log.txt | grep -m1 'warning'
--> warning 3

$ tac log.txt | sed '/warning/q' | tac
--> warning 3
4,3,1
</code></pre><p>The <code>log.txt</code> input file has multiple lines containing <code>warning</code>. The task is to fetch lines based on the last match. Tools like <code>grep</code> and <code>sed</code> have features to easily match the first occurrence, so applying <code>tac</code> on the input helps to reverse the condition from last match to first match. Another benefit is that the first <code>tac</code> will stop reading input contents after the match is found in the above examples.<p>By default, the newline character is used to split the input content into <em>lines</em>. You can use the <code>-s</code> option to specify a different string to be used as the separator. Here's an example:<pre><code class=language-bash>$ printf 'car\njeep\nbus\n' | tac
bus
jeep
car

# you can also use -s '' instead of -s $'\0'
$ printf 'car\0jeep\0bus\0' | tac -s $'\0' | cat -e
bus^@jeep^@car^@
</code></pre><blockquote><p><img src=./images/info.svg alt=info> Use the <code>rev</code> command if you want each input line to be reversed character wise.</blockquote></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=preface.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=head-tail.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=preface.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=head-tail.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>